"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[660],{4137:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=i,u=c["".concat(l,".").concat(m)]||c[m]||h[m]||o;return n?a.createElement(u,r(r({ref:t},p),{},{components:n})):a.createElement(u,r({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var d=2;d<o;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1415:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return p},default:function(){return c}});var a=n(7462),i=n(3366),o=(n(7294),n(4137)),r=["components"],s={slug:"/metadata-modeling/extending-the-metadata-model",title:"Extending the Metadata Model",sidebar_label:"Extending the Metadata Model",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/docs/modeling/extending-the-metadata-model.md"},l="Extending the Metadata Model",d={unversionedId:"docs/modeling/extending-the-metadata-model",id:"docs/modeling/extending-the-metadata-model",isDocsHomePage:!1,title:"Extending the Metadata Model",description:"You can extend the metadata model by either creating a new Entity or extending an existing one. Unsure if you need to",source:"@site/genDocs/docs/modeling/extending-the-metadata-model.md",sourceDirName:"docs/modeling",slug:"/metadata-modeling/extending-the-metadata-model",permalink:"/docs/metadata-modeling/extending-the-metadata-model",editUrl:"https://github.com/linkedin/datahub/blob/master/docs/modeling/extending-the-metadata-model.md",tags:[],version:"current",frontMatter:{slug:"/metadata-modeling/extending-the-metadata-model",title:"Extending the Metadata Model",sidebar_label:"Extending the Metadata Model",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/docs/modeling/extending-the-metadata-model.md"},sidebar:"overviewSidebar",previous:{title:"The Metadata Model",permalink:"/docs/metadata-modeling/metadata-model"},next:{title:"DataHub GraphQL API",permalink:"/docs/api/graphql/overview"}},p=[{value:"Defining an Entity",id:"defining-an-entity",children:[{value:'<a name="step_1"></a>Step 1: Define the Entity Key Aspect',id:"step-1-define-the-entity-key-aspect",children:[],level:3},{value:'<a name="step_2"></a>Step 2: Define custom aspects',id:"step-2-define-custom-aspects",children:[],level:3},{value:'<a name="step_3"></a>Step 3: Define the Entity Aspect Union',id:"step-3-define-the-entity-aspect-union",children:[],level:3},{value:'<a name="step_4"></a>Step 4: Define an Entity Snapshot',id:"step-4-define-an-entity-snapshot",children:[],level:3},{value:'<a name="step_5"></a>Step 5: Re-build DataHub to have access to your new or updated entity',id:"step-5-re-build-datahub-to-have-access-to-your-new-or-updated-entity",children:[],level:3},{value:'<a name="step_6"></a>(Optional) Step 6: Extend the DataHub frontend to view your entity in GraphQL &amp; React',id:"optional-step-6-extend-the-datahub-frontend-to-view-your-entity-in-graphql--react",children:[],level:3}],level:2},{value:"Metadata Annotations",id:"metadata-annotations",children:[{value:"@Entity",id:"entity",children:[{value:"Example",id:"example",children:[],level:5}],level:4},{value:"@Aspect",id:"aspect",children:[{value:"Example",id:"example-1",children:[],level:5}],level:4},{value:"@Searchable",id:"searchable",children:[{value:"Example",id:"example-2",children:[],level:5}],level:4},{value:"@Relationship",id:"relationship",children:[{value:"Example",id:"example-3",children:[],level:5}],level:4},{value:"Annotating Collections &amp; Annotation Overrides",id:"annotating-collections--annotation-overrides",children:[],level:4}],level:2}],h={toc:p};function c(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"extending-the-metadata-model"},"Extending the Metadata Model"),(0,o.kt)("p",null,"You can extend the metadata model by either creating a new Entity or extending an existing one. Unsure if you need to\ncreate a new entity or add an aspect to an existing entity? Read ",(0,o.kt)("a",{parentName:"p",href:"/docs/metadata-modeling/metadata-model"},"metadata-model")," to understand\nthese two concepts prior to making changes."),(0,o.kt)("p",null,"We will outline what the experience of adding a new Entity should look like through a real example of adding the\nDashboard Entity. If you want to extend an existing Entity, you can skip directly to ",(0,o.kt)("a",{parentName:"p",href:"#step_4"},"Step 4"),"."),(0,o.kt)("p",null,"At a high level, an entity is made up of:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"a union of Aspects, or bundles of related metadata,"),(0,o.kt)("li",{parentName:"ol"},"a Key Aspect, which uniquely identifies an instance of an entity,"),(0,o.kt)("li",{parentName:"ol"},"A snapshot, which pairs a group of aspects with a serialized key, or urn.")),(0,o.kt)("h2",{id:"defining-an-entity"},"Defining an Entity"),(0,o.kt)("p",null,'Now we\'ll walk through the steps required to create, ingest, and view your extensions to the metadata model. We will use\nthe existing "Dashboard" entity for purposes of illustration.'),(0,o.kt)("h3",{id:"step-1-define-the-entity-key-aspect"},(0,o.kt)("a",{name:"step_1"}),"Step 1: Define the Entity Key Aspect"),(0,o.kt)("p",null,"A key represents the fields that uniquely identify the entity. For those familiar with DataHub\u2019s legacy architecture,\nthese fields were previously part of the Urn Java Class that was defined for each entity."),(0,o.kt)("p",null,"This struct will be used to generate a serialized string key, represented by an Urn. Each field in the key struct will\nbe converted into a single part of the Urn's tuple, in the order they are defined."),(0,o.kt)("p",null,"Let\u2019s define a Key aspect for our new Dashboard entity."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'namespace com.linkedin.metadata.key\n\n/**\n * Key for a Dashboard\n */\n@Aspect = {\n  "name": "dashboardKey",\n}\nrecord DashboardKey {\n  /**\n  * The name of the dashboard tool such as looker, redash etc.\n  */\n  @Searchable = {\n    ...\n  }\n  dashboardTool: string\n\n  /**\n  * Unique id for the dashboard. This id should be globally unique for a dashboarding tool even when there are multiple deployments of it. As an example, dashboard URL could be used here for Looker such as \'looker.linkedin.com/dashboards/1234\'\n  */\n  dashboardId: string\n}\n\n')),(0,o.kt)("p",null,"The Urn representation of the Key shown above would be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"urn:li:dashboard:(<tool>,<id>)\n")),(0,o.kt)("p",null,"Because they are aspects, keys need to be annotated with an @Aspect annotation, This instructs DataHub that this struct\ncan be a part of."),(0,o.kt)("p",null,"The key can also be annotated with the two index annotations: @Relationship and @Searchable. This instructs DataHub\ninfra to use the fields in the key to create relationships and index fields for search. See ",(0,o.kt)("a",{parentName:"p",href:"#step_4"},"Step 4")," for more details on\nthe annotation model."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints"),": Note that each field in a Key Aspect MUST be of String or Enum type."),(0,o.kt)("h3",{id:"step-2-define-custom-aspects"},(0,o.kt)("a",{name:"step_2"}),"Step 2: Define custom aspects"),(0,o.kt)("p",null,"Some aspects, like Ownership and GlobalTags, are reusable across entities. They can be included in an entity\u2019s set of\naspects freely. To include attributes that are not included in an existing Aspect, a new Aspect must be created."),(0,o.kt)("p",null,"Let\u2019s look at the DashboardInfo aspect as an example of what goes into a new aspect."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'namespace com.linkedin.dashboard\n\nimport com.linkedin.common.AccessLevel\nimport com.linkedin.common.ChangeAuditStamps\nimport com.linkedin.common.ChartUrn\nimport com.linkedin.common.Time\nimport com.linkedin.common.Url\nimport com.linkedin.common.CustomProperties\nimport com.linkedin.common.ExternalReference\n\n/**\n * Information about a dashboard\n */\n@Aspect = {\n  "name": "dashboardInfo"\n}\nrecord DashboardInfo includes CustomProperties, ExternalReference {\n\n  /**\n   * Title of the dashboard\n   */\n  @Searchable = {\n    "fieldType": "TEXT_WITH_PARTIAL_MATCHING",\n    "queryByDefault": true,\n    "enableAutocomplete": true,\n    "boostScore": 10.0\n  }\n  title: string\n\n  /**\n   * Detailed description about the dashboard\n   */\n  @Searchable = {\n    "fieldType": "TEXT",\n    "queryByDefault": true,\n    "hasValuesFieldName": "hasDescription"\n  }\n  description: string\n\n  /**\n   * Charts in a dashboard\n   */\n  @Relationship = {\n    "/*": {\n      "name": "Contains",\n      "entityTypes": [ "chart" ]\n    }\n  }\n  charts: array[ChartUrn] = [ ]\n \n  /**\n   * Captures information about who created/last modified/deleted this dashboard and when\n   */\n  lastModified: ChangeAuditStamps\n\n  /**\n   * URL for the dashboard. This could be used as an external link on DataHub to allow users access/view the dashboard\n   */\n  dashboardUrl: optional Url\n\n  /**\n   * Access level for the dashboard\n   */\n  @Searchable = {\n    "fieldType": "KEYWORD",\n    "addToFilters": true\n  }\n  access: optional AccessLevel\n\n  /**\n   * The time when this dashboard last refreshed\n   */\n  lastRefreshed: optional Time\n}\n')),(0,o.kt)("p",null,"The Aspect has four key components: its properties, the @Aspect annotation, the @Searchable annotation and the\n@Relationship annotation. Let\u2019s break down each of these:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Aspect properties"),": The record\u2019s properties can be declared as a field on the record, or by including another\nrecord in the Aspect\u2019s definition (",(0,o.kt)("inlineCode",{parentName:"li"},"record DashboardInfo includes CustomProperties, ExternalReference {"),"). Properties\ncan be defined as PDL primitives, enums, records, or collections (\nsee ",(0,o.kt)("a",{parentName:"li",href:"https://linkedin.github.io/rest.li/pdl_schema"},"pdl schema documentation"),")\nreferences to other entities, of type Urn or optionally ",(0,o.kt)("inlineCode",{parentName:"li"},"<Entity>Urn")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"@Aspect annotation"),": Declares record is an Aspect and includes it in an entity\u2019s Snapshot. Unlike the following\ntwo annotations, @Aspect is applied to the entire record, rather than a specific field.  Note, you can mark an aspect\nas a timeseries aspect. Check out this ",(0,o.kt)("a",{parentName:"li",href:"/docs/metadata-modeling/metadata-model#timeseries-aspects"},"doc")," for details."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"@Searchable annotation"),": This annotation can be applied to any primitive field or a map field to indicate that it\nshould be indexed in Elasticsearch and can be searched on. For a complete guide on using the search annotation, see\nthe annotation docs further down in this document."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"@Relationship annotation"),": These annotations create edges between the Snapshot\u2019s Urn and the destination of the\nannotated field when the snapshots are ingested. @Relationship annotations must be applied to fields of type Urn. In\nthe case of DashboardInfo, the ",(0,o.kt)("inlineCode",{parentName:"li"},"charts")," field is an Array of Urns. The @Relationship annotation cannot be applied\ndirectly to an array of Urns. That\u2019s why you see the use of an Annotation override (`\u201d/*\u201d:) to apply the @Relationship\nannotation to the Urn directly. Read more about overrides in the annotation docs further down on this page.")),(0,o.kt)("p",null,"After you create your Aspect, you need to add it into the Aspect Union of each entity you\u2019d like to attach the aspect\nto. Refer back to ",(0,o.kt)("a",{parentName:"p",href:"#step_2"},"Step 2")," for how Aspects are added to Aspect Unions."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints"),": Note that all aspects MUST be of type Record."),(0,o.kt)("h3",{id:"step-3-define-the-entity-aspect-union"},(0,o.kt)("a",{name:"step_3"}),"Step 3: Define the Entity Aspect Union"),(0,o.kt)("p",null,"You must create an Aspect union to define what aspects an Entity is associated with. An aspect represents a related\nrecord of metadata about an entity. Any record appearing in the Union should be annotated with @Aspect."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"namespace com.linkedin.metadata.aspect\n\nimport com.linkedin.metadata.key.DashboardKey\nimport com.linkedin.dashboard.DashboardInfo\nimport com.linkedin.common.Ownership\nimport com.linkedin.common.Status\nimport com.linkedin.common.GlobalTags\nimport com.linkedin.common.BrowsePaths\n\n/**\n * A union of all supported metadata aspects for a Dashboard\n */\ntyperef DashboardAspect = union[\n    DashboardKey,\n    DashboardInfo,\n    Ownership,\n    Status,\n    GlobalTags,\n    BrowsePaths\n]\n")),(0,o.kt)("p",null,"The first aspect will be by convention the Entity\u2019s key aspect. Other aspects can be Dashboard specific, like\nDashboardInfo, or common, such as Ownership. This union can be extended over time as you expand the metadata model. You\ncan include any existing type with the @Aspect annotation in your entity\u2019s aspect union or create new ones- The next step\ngoes into detail about how to create a new Aspect."),(0,o.kt)("p",null,"To extend an existing entity, simply add your new Aspect to the Entity's list of aspect via the Aspect Union model."),(0,o.kt)("h3",{id:"step-4-define-an-entity-snapshot"},(0,o.kt)("a",{name:"step_4"}),"Step 4: Define an Entity Snapshot"),(0,o.kt)("p",null,"The snapshot describes the format of how an entity is serialized for read and write operations to GMS, the Generic\nMetadata Store. All snapshots have two fields:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"urn")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"Urn")," "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"snapshot")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"union[Aspect1, Aspect2, ...]"),".")),(0,o.kt)("p",null,"The snapshot needs an ",(0,o.kt)("inlineCode",{parentName:"p"},"@Entity")," annotation with the entity\u2019s name. The name is used for specifying entity type when\nsearching, using autocomplete, etc."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'namespace com.linkedin.metadata.snapshot\n\nimport com.linkedin.common.DashboardUrn\nimport com.linkedin.metadata.aspect.DashboardAspect\n\n/**\n * A metadata snapshot for a specific Dashboard entity.\n */\n@Entity = {\n  "name": "dashboard"\n}\nrecord DashboardSnapshot {\n\n  /**\n   * URN for the entity the metadata snapshot is associated with.\n   */\n  urn: DashboardUrn\n\n  /**\n   * The list of metadata aspects associated with the dashboard.\n   */\n  aspects: array[DashboardAspect]\n}\n')),(0,o.kt)("p",null,"If you're extending an existing Entity, you can skip this step."),(0,o.kt)("h3",{id:"step-5-re-build-datahub-to-have-access-to-your-new-or-updated-entity"},(0,o.kt)("a",{name:"step_5"}),"Step 5: Re-build DataHub to have access to your new or updated entity"),(0,o.kt)("p",null,"If you have updated any existing types or see an ",(0,o.kt)("inlineCode",{parentName:"p"},"Incompatible changes")," warning when building, you will need to run\n",(0,o.kt)("inlineCode",{parentName:"p"},"./gradlew :gms:impl:build -Prest.model.compatibility=ignore"),"\nbefore running ",(0,o.kt)("inlineCode",{parentName:"p"},"build"),"."),(0,o.kt)("p",null,"Then, run ",(0,o.kt)("inlineCode",{parentName:"p"},"./gradlew build")," from the repository root to rebuild Datahub with access to your new entity."),(0,o.kt)("p",null,"Then, re-deploy gms, mae-consumer and mce-consumer (see ",(0,o.kt)("a",{parentName:"p",href:"/docs/docker"},"docker development")," for details on how\nto deploy during development). This will allow Datahub to read and write Snapshots of your new entity, along with server\nsearch and graph queries for that entity type."),(0,o.kt)("p",null,"To emit snapshots to ingest from the Datahub CLI tool, first install datahub cli\nlocally ",(0,o.kt)("a",{parentName:"p",href:"/docs/metadata-ingestion/developing"},"following the instructions here"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"./gradlew build")," generated the avro\nschemas your local ingestion cli tool uses earlier. After following the developing guide, you should be able to emit\nyour new event using the local datahub cli."),(0,o.kt)("p",null,"Now you are ready to start ingesting metadata for your new entity!"),(0,o.kt)("h3",{id:"optional-step-6-extend-the-datahub-frontend-to-view-your-entity-in-graphql--react"},(0,o.kt)("a",{name:"step_6"}),"(Optional) Step 6: Extend the DataHub frontend to view your entity in GraphQL & React"),(0,o.kt)("p",null,"At the moment, custom React and Grapqhl code needs to be written to view your entity in GraphQL or React. For\ninstructions on how to start extending the GraphQL graph, see ",(0,o.kt)("a",{parentName:"p",href:"/docs/datahub-graphql-core"},"graphql docs"),". Once\nyou\u2019ve done that, you can follow the guide ",(0,o.kt)("a",{parentName:"p",href:"/docs/datahub-web-react"},"here")," to add your entity into the React\nUI."),(0,o.kt)("h2",{id:"metadata-annotations"},"Metadata Annotations"),(0,o.kt)("p",null,"There are four core annotations that DataHub recognizes:"),(0,o.kt)("h4",{id:"entity"},"@Entity"),(0,o.kt)("p",null,"This annotation is applied to each Entity Snapshot record, such as DashboardSnapshot.pdl. Each one that is included in\nthe root Snapshot.pdl model must have this annotation."),(0,o.kt)("p",null,"It takes the following parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"name"),": string - A common name used to identify the entity. Must be unique among all entities DataHub is aware of.")),(0,o.kt)("h5",{id:"example"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-aidl"},"@Entity = {\n  // name used when referring to the entity in APIs.\n  String name;\n}\n")),(0,o.kt)("h4",{id:"aspect"},"@Aspect"),(0,o.kt)("p",null,"This annotation is applied to each Aspect record, such as DashboardInfo.pdl. Each aspect that is included in an entity\u2019s\nAspectUnion must have this annotation."),(0,o.kt)("p",null,"It takes the following parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"name"),": string - A common name used to identify the Aspect. Must be unique among all aspects DataHub is aware of."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"type"),': string (optional) - set to "timeseries" to mark this aspect as timeseries. Check out\nthis ',(0,o.kt)("a",{parentName:"li",href:"/docs/metadata-modeling/metadata-model#timeseries-aspects"},"doc")," for details.")),(0,o.kt)("h5",{id:"example-1"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-aidl"},"@Aspect = {\n  // name used when referring to the aspect in APIs.\n  String name;\n}\n")),(0,o.kt)("h4",{id:"searchable"},"@Searchable"),(0,o.kt)("p",null,"This annotation is applied to fields inside an Aspect. It instructs DataHub to index the field so it can be retrieved\nvia the search APIs."),(0,o.kt)("p",null,"It takes the following parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"fieldType"),": string - The settings for how each field is indexed is defined by the field type. Each field type is\nassociated with a set of analyzers Elasticsearch will use to tokenize the field. Such sets are defined in the\nMappingsBuider, which generates the mappings for the index for each entity given the fields with the search\nannotations. To customize the set of analyzers used to index a certain field, you must add a new field type and define\nthe set of mappings to be applied in the MappingsBuilder."),(0,o.kt)("p",{parentName:"li"},"Thus far, we have implemented 8 fieldTypes:"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"KEYWORD")," - Short text fields that only support exact matches, often used only for filtering")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"TEXT")," - Text fields delimited by spaces/slashes/periods. Default field type for string variables.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"TEXT_PARTIAL")," - Text fields delimited by spaces/slashes/periods with partial matching support. Note, partial\nmatching is expensive, so this field type should not be applied to fields with long values (like description)")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"BROWSE_PATH")," - Field type for browse paths. Applies specific mappings for slash delimited paths.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"URN"),' - Urn fields where each sub-component inside the urn is indexed. For instance, for a data platform urn like\n"urn:li:dataplatform:kafka", it will index the platform name "kafka" and ignore the common components')),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"URN_PARTIAL")," - Urn fields where each sub-component inside the urn is indexed with partial matching support.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"BOOLEAN")," - Boolean fields used for filtering.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("em",{parentName:"p"},"COUNT")," - Count fields used for filtering.")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"fieldName"),": string (optional) - The name of the field in search index document. Defaults to the field name where\nthe annotation resides.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"queryByDefault"),": boolean (optional) - Whether we should match the field for the default search query. True by\ndefault for text and urn fields.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"enableAutocomplete"),": boolean (optional) - Whether we should use the field for autocomplete. Defaults to false")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"addToFilters"),": boolean (optional) - Whether or not to add field to filters. Defaults to false")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"boostScore"),": double (optional) - Boost multiplier to the match score. Matches on fields with higher boost score\nranks higher.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"hasValuesFieldName"),": string (optional) - If set, add an index field of the given name that checks whether the field\nexists")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"numValuesFieldName"),": string (optional) - If set, add an index field of the given name that checks the number of\nelements")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"weightsPerFieldValue"),": map","[object, double]"," (optional) - Weights to apply to score for a given value."))),(0,o.kt)("h5",{id:"example-2"},"Example"),(0,o.kt)("p",null,"Let\u2019s take a look at a real world example using the ",(0,o.kt)("inlineCode",{parentName:"p"},"title")," field of ",(0,o.kt)("inlineCode",{parentName:"p"},"DashboardInfo.pdl"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-aidl"},'record DashboardInfo {\n /**\n   * Title of the dashboard\n   */\n  @Searchable = {\n    "fieldType": "TEXT_PARTIAL",\n    "enableAutocomplete": true,\n    "boostScore": 10.0\n  }\n  title: string\n  ....\n}\n')),(0,o.kt)("p",null,"This annotation is saying that we want to index the title field in Elasticsearch. We want to support partial matches on\nthe title, so queries for ",(0,o.kt)("inlineCode",{parentName:"p"},"Cust")," should return a Dashboard with the title ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"enableAutocomplete")," is set to\ntrue, meaning that we can autocomplete on this field when typing into the search bar. Finally, a boostScore of 10 is\nprovided, meaning that we should prioritize matches to title over matches to other fields, such as description, when\nranking."),(0,o.kt)("p",null,"Now, when Datahub ingests Dashboards, it will index the Dashboard\u2019s title in Elasticsearch. When a user searches for\nDashboards, that query will be used to search on the title index and matching Dashboards will be returned."),(0,o.kt)("p",null,'Note, when @Searchable annotation is applied to a map, it will convert it into a list with "key.toString()\n=value.toString()" as elements. This allows us to index map fields, while not increasing the number of columns indexed.'),(0,o.kt)("h4",{id:"relationship"},"@Relationship"),(0,o.kt)("p",null,"This annotation is applied to fields inside an Aspect. This annotation creates edges between an Entity\u2019s Urn and the\ndestination of the annotated field when the Entity is ingested. @Relationship annotations must be applied to fields of\ntype Urn."),(0,o.kt)("p",null,"It takes the following parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"name"),": string - A name used to identify the Relationship type."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"entityTypes"),": array","[string]"," (Optional) - A list of entity types that are valid values for the foreign-key\nrelationship field.")),(0,o.kt)("h5",{id:"example-3"},"Example"),(0,o.kt)("p",null,"Let\u2019s take a look at a real world example to see how this annotation is used. The ",(0,o.kt)("inlineCode",{parentName:"p"},"Owner.pdl")," struct is referenced by\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"Ownership.pdl")," aspect. ",(0,o.kt)("inlineCode",{parentName:"p"},"Owned.pdl")," contains a relationship to a CorpUser or CorpGroup:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'namespace com.linkedin.common\n\n/**\n * Ownership information\n */\nrecord Owner {\n\n  /**\n   * Owner URN, e.g. urn:li:corpuser:ldap, urn:li:corpGroup:group_name, and urn:li:multiProduct:mp_name\n   */\n  @Relationship = {\n    "name": "OwnedBy",\n    "entityTypes": [ "corpUser", "corpGroup" ]\n  }\n  owner: Urn\n\n  ...\n}\n')),(0,o.kt)("p",null,"This annotation says that when we ingest an Entity with an OwnershipAspect, DataHub will create an OwnedBy relationship\nbetween that entity and the CorpUser or CorpGroup who owns it. This will be queryable using the Relationships resource\nin both the forward and inverse directions."),(0,o.kt)("h4",{id:"annotating-collections--annotation-overrides"},"Annotating Collections & Annotation Overrides"),(0,o.kt)("p",null,"You will not always be able to apply annotations to a primitive field directly. This may be because the field is wrapped\nin an Array, or because the field is part of a shared struct that many entities reference. In these cases, you need to\nuse annotation overrides. An override is done by specifying a fieldPath to the target field inside the annotation, like\nso:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},' /**\n   * Charts in a dashboard\n   */\n  @Relationship = {\n    "/*": {\n      "name": "Contains",\n      "entityTypes": [ "chart" ]\n    }\n  }\n  charts: array[ChartUrn] = [ ]\n')),(0,o.kt)("p",null,"This override applies the relationship annotation to each element in the Array, rather than the array itself. This\nallows a unique Relationship to be created for between the Dashboard and each of its charts."),(0,o.kt)("p",null,"Another example can be seen in the case of tags. In this case, TagAssociation.pdl has a @Searchable annotation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},' @Searchable = {\n    "fieldName": "tags",\n    "fieldType": "URN_WITH_PARTIAL_MATCHING",\n    "queryByDefault": true,\n    "hasValuesFieldName": "hasTags"\n  }\n  tag: TagUrn\n')),(0,o.kt)("p",null,"At the same time, SchemaField overrides that annotation to allow for searching for tags applied to schema fields\nspecifically. To do this, it overrides the Searchable annotation applied to the ",(0,o.kt)("inlineCode",{parentName:"p"},"tag")," field of ",(0,o.kt)("inlineCode",{parentName:"p"},"TagAssociation")," and\nreplaces it with its own- this has a different boostScore and a different fieldName."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},' /**\n   * Tags associated with the field\n   */\n  @Searchable = {\n    "/tags/*/tag": {\n      "fieldName": "fieldTags",\n      "fieldType": "URN_WITH_PARTIAL_MATCHING",\n      "queryByDefault": true,\n      "boostScore": 0.5\n    }\n  }\n  globalTags: optional GlobalTags\n')),(0,o.kt)("p",null,"As a result, you can issue a query specifically for tags on Schema Fields via ",(0,o.kt)("inlineCode",{parentName:"p"},"fieldTags:<tag_name>")," or tags directly\napplied to an entity via ",(0,o.kt)("inlineCode",{parentName:"p"},"tags:<tag_name>"),". Since both have ",(0,o.kt)("inlineCode",{parentName:"p"},"queryByDefault")," set to true, you can also search for\nentities with either of these properties just by searching for the tag name."))}c.isMDXComponent=!0}}]);